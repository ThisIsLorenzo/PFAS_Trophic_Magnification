---
title: "Analysis Code"
author: "Lorenzo Ricolfi"
output:
  html_document:
    code_folding: show
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    toc_depth: 3
    number_sections: no
    theme: cerulean
  pdf_document:
    toc: yes
    toc_depth: '2'
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Packages

The following packages are required to run the code in this script.
```{r, echo=TRUE, results='hide', warning=FALSE, message=FALSE}
#devtools::install_github("EIvimeyCook/ShinyDigitise")
#library(shinyDigitise)
pacman::p_load(tidyr,       # For tidying data, including reshaping and separating data into columns.
               dplyr,       # For data manipulation, including filtering, selecting, and summarizing data.
               stringr,     # For string manipulation, including pattern matching and text extraction.
               readr,
               here,        # For constructing file paths relative to the root of the project directory.
               lmtest,      # For conducting diagnostic tests and hypothesis tests on linear models.
               dm,          # For working with data models and relational data within R.
               data.table,  # For fast and efficient data manipulation, particularly with large datasets.
               metaDigitise,# For extracting and digitizing data from plots in scientific literature.
               clubSandwich,# For computing robust standard errors in meta-analysis, particularly in clustered data.
               metafor,     # For conducting meta-analyses, including univariate and multivariate models.
               orchaRd,     # For visualizing meta-analysis results, including bubble plots and forest plots.
               ggplot2,     # For creating complex and customizable visualizations using the grammar of graphics.
               MuMIn,       # For model selection and model averaging, particularly in regression models.
               kableExtra,  # Enhances the formatting capabilities of tables
               patchwork,   # Facilitates combining multiple ggplot2 plots into a single layout
               ggalluvial,  # Extends ggplot2 to create alluvial diagrams
               ggbreak,
               rnaturalearth,
               rnaturalearthdata,
               officer,
               flextable,
               ggsci, 
               forcats)  


```

```{r, eval=FALSE, include=FALSE}
dat <- metaDigitise("~/PhD/GitHub/PFAS_Trophic_Magnification/metaDigitise")
dat <- shinyDigitise("~/PhD/GitHub/PFAS_Trophic_Magnification/metaDigitise")
#write.csv(dat, file = "metaDigitise/MetaDigitise_Martin_2004_10r.csv")
```

# Data uploading and wrangling

We need to perform data wrangling to optimally structure the data for analysis. The following code chunk outlines the steps taken, along with brief descriptions of each.
```{r, results='hide', warning=FALSE}
study_data <- read.csv(here("data/study_data.csv"))
 fw_data <- read.csv(here("data/fw_data.csv"))
 PFAS_data <- read.csv(here("data/PFAS_data.csv"))
 TMF_data <- read.csv(here("data/TMF_data.csv"))
# appr_data <- read.csv(here("data/appr_data.csv"))

TMF_data <- TMF_data %>%
  mutate(across(everything(), # Replace "na" strings with actual NA values
                ~ ifelse(. == "na", NA, .)))

function1 <- function(data) {
  # Convert necessary columns to numeric, handling any potential issues
  data <- data %>%
    mutate(
      TMF_lower_95CI = as.numeric(TMF_lower_95CI),
      TMF_upper_95CI = as.numeric(TMF_upper_95CI),
      TMF_se = as.numeric(TMF_se),
      TMS_lower_95CI = as.numeric(TMS_lower_95CI),
      TMS_upper_95CI = as.numeric(TMS_upper_95CI),
      TMS_se = as.numeric(TMS_se),
      TMS = as.numeric(TMS),
      TMF = as.numeric(TMF),
      pvalue_adj = as.numeric(pvalue_adj),
      TMS_calculated = as.numeric(TMS_calculated),
      TMS_se_calculated = as.numeric(TMS_se_calculated)
    ) %>%
    mutate(
      # Calculate TMF_se if missing and TMF 95% CI is available
      TMF_se = ifelse(is.na(TMF_se) & !is.na(TMF_lower_95CI) & !is.na(TMF_upper_95CI),
                      (TMF_upper_95CI - TMF_lower_95CI) / 1.96, TMF_se),
      # Calculate TMS_se if missing and TMS 95% CI is available
      TMS_se = ifelse(is.na(TMS_se) & !is.na(TMS_lower_95CI) & !is.na(TMS_upper_95CI),
                      (TMS_upper_95CI - TMS_lower_95CI) / 1.96, TMS_se),
      # Calculate TMF if missing and TMS is available
      TMF = ifelse(is.na(TMF) & !is.na(TMS),
                   ifelse(TMF_formula == "10^slope", 10^TMS, exp(TMS)), TMF),
      # Calculate z_value if TMS_se is missing and pvalue_adj is available 
      z_value = ifelse(is.na(TMS_se) & !is.na(pvalue_adj),
                       qnorm(1 - pvalue_adj / 2), NA),
      # Calculate TMS if missing and TMF is available
      TMS = ifelse(is.na(TMS) & !is.na(TMF),
                   ifelse(TMF_formula == "10^slope", log10(TMF), log(TMF)), TMS),
      # Calculate TMS_se if missing, TMS, and z_value are available
      TMS_se = ifelse(is.na(TMS_se) & !is.na(TMS) & !is.na(z_value),
                      TMS / z_value, TMS_se),
      # Calculate TMS_se if TMS is missing, but TMF and z_value are available
      TMS_se = ifelse(is.na(TMS) & !is.na(TMF) & !is.na(z_value),
                      ifelse(TMF_formula == "10^slope", log10(TMF) / z_value, log(TMF) / z_value), TMS_se),
      # Calculate TMF_se if missing and TMS_se is available 
      TMF_se = ifelse(is.na(TMF_se) & !is.na(TMS_se),
                      ifelse(TMF_formula == "10^slope", 10^TMS_se, exp(TMS_se)), TMF_se),
      # Calculate TMF if missing and TMS_calculated is available
      TMF = ifelse(is.na(TMF) & !is.na(TMS_calculated),
                   ifelse(TMF_formula == "10^slope", 10^TMS_calculated, exp(TMS_calculated)), TMF),
      # Calculate TMF_se if missing and TMS_se_calculated is available
      TMF_se = ifelse(is.na(TMF_se) & !is.na(TMS_se_calculated),
                      ifelse(TMF_formula == "10^slope", 10^TMS_se_calculated, exp(TMS_se_calculated)), TMF_se)
    )
  # Return the modified data
  return(data)
}

# Apply the function
TMF_data <- function1(TMF_data)

# Count the number of rows with non-NA values in both TMF and TMF_se
TMF_data %>%
  filter(!is.na(TMF) & !is.na(TMF_se)) %>%
  nrow()
# [1] 981


TMF_data <- TMF_data %>%
  filter(!is.na(TMF) | !is.na(TMF_se)) %>%
  mutate(
    ln_TMF = log(TMF),
    ln_TMF_se = TMF_se / TMF, # Taylor approximation
    Sample_type = factor(Sample_type), # Convert to factor
    Sample_type = relevel(Sample_type, ref = "whole-organisms only") # Relevel
  ) 
  

TMF_data <- TMF_data %>% 
  select(-(starts_with("Initial"))) %>% #removing any column starting with initials
  select(-(starts_with("X"))) %>% #removing any column starting with X
  select(-(ends_with("comment"))) %>%  #removing any column ending with comment
  select(-("Study_ID")) #removing Study_ID column because redundant

PFAS_data <- PFAS_data %>% 
  select(-(starts_with("Initial"))) %>% #removing any column starting with initials
  select(-(starts_with("X"))) %>% #removing any column starting with X
  select(-(ends_with("comment"))) #removing any column ending with comment

fw_data <- fw_data %>% 
  select(-(starts_with("Initial"))) %>% #removing any column starting with initials
  select(-(starts_with("X"))) %>% #removing any column starting with X
  select(-(ends_with("comment"))) #removing any column ending with comment

study_data <- study_data %>% 
  select(-(starts_with("Initials"))) %>% #removing any column starting with initials
  select(-(starts_with("X"))) %>% #removing any column starting with X
  select(-(ends_with("comment"))) %>%  #removing any column ending with comment
  filter(!is.na(Study_ID) & Study_ID != "") %>%  #removing rows where Study_ID is empty (either NA or "")
  mutate(Regression_variable = case_when(
    grepl("TL", Linear_regression_formula) ~ "TL",
    grepl("δ15N", Linear_regression_formula) ~ "δ15N",
    TRUE ~ NA_character_
  )) %>%
  mutate(year_publication = as.numeric(str_extract(Author_year, "(?<=_)\\d{4}")))

TMF_data <- TMF_data %>%
  # Correct mislabelings in the PFAS_ID column (TMF_data data table)
  mutate(PFAS_ID = case_when(
    PFAS_ID == "PFDoDa" ~ "PFDoDA",
    PFAS_ID == "br-PFDoDa" ~ "br-PFDoDA",
    TRUE ~ PFAS_ID
  )) %>% 
  # Filter the data to remove rows where Sample_type is NA or an empty string
  filter(!is.na(Sample_type) & Sample_type != "")

PFAS_data <- PFAS_data %>%
  # Correct mislabeling in the PFAS_ID column (PFAS_data data table)
  mutate(PFAS_ID = case_when(
    PFAS_ID == "cis-PFECHS " ~ "cis-PFECHS",
    TRUE ~ PFAS_ID
  ))

fw_data <- fw_data %>%
  # Trim whitespace
  mutate(Latitude_DD = str_trim(Latitude_DD)) %>%
  # Remove the ° symbol and any non-numeric characters
  mutate(Latitude_DD = str_replace_all(Latitude_DD, "[^0-9.-]", "")) %>%
  # Convert to numeric
  mutate(Latitude_DD = as.numeric(Latitude_DD)) %>%
  # Trim whitespace
  mutate(Longitude_DD = str_trim(Longitude_DD)) %>%
  # Remove the ° symbol and any non-numeric characters
  mutate(Longitude_DD = str_replace_all(Longitude_DD, "[^0-9.-]", "")) %>%
  # Convert to numeric
  mutate(Longitude_DD = as.numeric(Longitude_DD))

fw_data <- fw_data %>%
  mutate(Breathing_type_fw = case_when(
    Species_composition %in% c(
      "fish only"
    ) ~ "water-breathing only",
    
    Species_composition %in% c(
      "fish and other species", "no fish"
    ) ~ "not water-breathing only",
    
    TRUE ~ NA_character_  # Assign NA for any species not in the lists
  )) %>% 
  mutate(
    Ecosystem = factor(Ecosystem),
    Ecosystem = relevel(Ecosystem, ref = "marine")) # Relevel
    

fw_data <- fw_data %>%
  mutate(Breathing_type = case_when(
    Species_highest_TL %in% c(
      "Delphinapterus leucas", "Delphinus truncatus", "Larus hyperboreus", 
      "Channa asiatica", "Argyrosomus regius", "Larus crassirostris", 
      "Neophocaena", "Pusa hispida", "Sousa chinensis", 
      "Catharacta maccormicki", "Buteo hemilasius", "Canis lupus", 
      "Accipiter nisus", "Accipiter cooperii"
    ) ~ "Air breathing",
    
    Species_highest_TL %in% c(
      "Boreogadus saida", "Barbus barbus", "Squalius cephalus", 
      "Cololabis saira", "Salvelinus alpinus", "Salvelinus namaycush", 
      "Micropterus salmoides", "Notothenia coriiceps", "Esox lucius", 
      "Pagrosomus major", "Lateolabrax japonicas", "Thryssa mysiax", 
      "Trichiurus lepturus", "Hexagrammos otakii", "Rapana venosa", 
      "Sander lucioperca", "Salvelinus fontinalis", "Morone saxatilis", 
      "Channa argus", "Micropterus dolomieu", "Johnius belengeri", 
      "Trematomus eulepidotus", "Miichthys miiuy", "Ophiocephalus argus Cantor", 
      "Liza carinatus", "Sander vitreus", "Sebastes schlegeli", 
      "Hemibarbus maculates", "Merlangius merlangus", "Gaidropsarus vulgaris", 
      "Clarias macrocephalus", "Carassius auratus", "Oreochromis niloticus", 
      "Phoca vitulina", "Parabramis pekinensis", "Lateolabrax sp.", 
      "Sarda sarda"
    ) ~ "Water breathing",
    
    Species_highest_TL %in% c(
      "Hydropsychidae", "Polychaeta", "Zygoptera", "Lithobiomorph", 
      "Araneae"
    ) ~ "Water breathing through skin",  # Many aquatic larvae breathe through skin

    TRUE ~ NA_character_  # Assign NA for any species not in the lists
  ))

# The following function finds the highest and lowest trophic level processing TL_values for each row. Then, we also calculate the length of the food web using these values.

process_TL_extremes <- function(TL_string) {
  # Split the string by commas
  values <- unlist(strsplit(TL_string, ","))
  
  # Process each value
  processed_values <- sapply(values, function(value) {
    value <- str_trim(value) # Trim any whitespace
    
    # Skip processing if the value is NA or empty
    if (is.na(value) || value == "") {
      return(NA)
    }
    
    # Check if it's a range (e.g., 3.12-3.64)
    if (str_detect(value, "-")) {
      range_values <- as.numeric(unlist(strsplit(value, "-")))
      return(range_values)
    
    # Check if it's a value with error (e.g., 1.83±0.09)
    } else if (str_detect(value, "±")) {
      mean_value <- as.numeric(unlist(strsplit(value, "±"))[1])
      return(mean_value)
    
    # Otherwise, it's a simple numeric value
    } else {
      return(as.numeric(value))
    }
  })
  
  # Unlist the processed values and remove NAs
  processed_values <- unlist(processed_values)
  processed_values <- processed_values[!is.na(processed_values)]
  
  # Return the highest and lowest values, handle empty processed_values
  if (length(processed_values) == 0) {
    return(list(highest = NA, lowest = NA))
  } else {
    return(list(highest = max(processed_values, na.rm = TRUE), 
                lowest = min(processed_values, na.rm = TRUE)))
  }
}

# Apply the function to each row in the TL_values column to get TL_highest and TL_lowest
fw_data <- fw_data %>%
  mutate(TL_extremes = lapply(TL_values, process_TL_extremes)) %>%
  mutate(TL_highest = sapply(TL_extremes, function(x) x$highest),
         TL_lowest = sapply(TL_extremes, function(x) x$lowest)) %>%
  select(-TL_extremes)  # Remove the temporary TL_extremes column

fw_data <- fw_data %>%
  # Create a new column for the difference
  mutate(fw_length = TL_highest - TL_lowest)

# The following code creates a data model object called data_dm_no_keys using the dm() function, with the tables st, sp, pfas, co, sa, and me.
data_dm_no_keys <- dm(study_data, PFAS_data, fw_data, TMF_data)
data_dm_no_keys #printing the data_dm_no_keys object, which displays the structure and content of the data model
data_dm_no_keys$study_data #accessing the study_data table from the data model using $ operator and printing it
data_dm_no_keys[c("study_data", "PFAS_data")] #accessing the columns "study_data" and "PFAS_data" from the data model using indexing and printing the corresponding data

# The following code adds primary keys to the data_dm_no_keys data model using the dm_add_pk() function. It specifies the table and the corresponding column(s) to be used as primary keys for each table. The resulting data model with only primary keys is stored in the data_dm_only_pks object and printed. Next, foreign keys are added to the data_dm_only_pks data model using the dm_add_fk() function. It specifies the table, columns, and the referenced table for each foreign key constraint. The resulting data model with both primary and foreign keys is stored in the data_dm_all_keys object and printed.
data_dm_only_pks <- data_dm_no_keys %>% 
  dm_add_pk(table = study_data, columns = Study_ID) %>% 
  dm_add_pk(PFAS_data, PFAS_ID) %>% 
  dm_add_pk(fw_data, FW_ID) %>% 
  dm_add_pk(TMF_data, TMF_ID)
data_dm_only_pks

data_dm_all_keys <- 
  data_dm_only_pks %>% 
  dm_add_fk(table = fw_data, columns = Study_ID, ref_table = study_data) %>% 
  dm_add_fk(table = TMF_data, columns = FW_ID, ref_table = fw_data) %>% 
  dm_add_fk(table = TMF_data, columns = PFAS_ID, ref_table = PFAS_data)
data_dm_all_keys

# Create a palette of 70 colors using a range from a selection of base colors
color_palette <- colorRampPalette(c("red", "blue", "green", "purple", "orange", "pink", "yellow"))(70)
```


```{r}
# Data model visualization:
data_dm_all_keys %>% 
  dm_draw()
 # Data model integrity check:
data_dm_all_keys %>% 
  dm_examine_constraints()
```

```{r, results='hide'}
# The following chunk creates a new table (i.e., 'TMF_data2') that merges 'study_data', 'PFAS_data', 'fw_data', and 'TMF_data' tables.
TMF_data2 <- 
  data_dm_all_keys %>%
  dm_select_tbl(TMF_data, fw_data, PFAS_data, study_data) %>%
  dm_flatten_to_tbl(.start = TMF_data, .recursive = TRUE, .join = left_join) 

colnames(TMF_data2)
# Count the number of studies with non-NA values in both TMF and TMF_se
TMF_data2 %>%
  filter(!is.na(TMF) & !is.na(TMF_se)) %>%
  distinct(Study_ID) %>%
  count()
# [1] 63

# Save the table
#write.csv(TMF_data2, here("data/TMF_data2.csv"), row.names = FALSE)
```

# VCV matrix

The following code creates a variance-covariance matrix (VCV) using the vcalc function:
```{r, warning=FALSE}
VCV <- vcalc(vi = TMF_data2$ln_TMF_se^2, #Specifies the variance of the effect sizes
             cluster = TMF_data2$FW_ID, #Indicates the clustering variable
             obs = TMF_data2$TMF_ID, #Identifies each unique observation by its TMF_ID, allowing the function to calculate covariances between effect sizes that share a cluster.
             rho = 0.5) #Sets the assumed correlation between effect sizes within the same cluster. This correlation reflects how much the effect sizes are expected to covary within the same food web.
```

# Modifying OrchaRd plot function

The following code modifies the OrchaRd plot function to display model outputs on the natural log scale (ln_TMF) while presenting the plots on the original scale (TMF), enhancing the visual interpretation of the results.
```{r, results='hide', warning=FALSE}
orchard_plot_new <- function (object, mod = "1", group, xlab, N = NULL, alpha = 0.5, 
    angle = 90, cb = TRUE, k = TRUE, g = TRUE, tree.order = NULL, 
    trunk.size = 1, branch.size = 1.2, twig.size = 0.5, transfm = c("none", 
        "tanh", "invlogit", "percent", "percentr"), condition.lab = "Condition", 
    legend.pos = c("bottom.right", "bottom.left", "top.right", 
        "top.left", "top.out", "bottom.out", "none"), k.pos = c("right", 
        "left", "none"), colour = FALSE, fill = TRUE, weights = "prop", 
    by = NULL, at = NULL, upper = TRUE, flip = TRUE) 
{
    transfm <- match.arg(NULL, choices = transfm)
    legend.pos <- match.arg(NULL, choices = legend.pos)
    k.pos <- match.arg(NULL, choices = k.pos)
    if (any(class(object) %in% c("robust.rma", "rma.mv", "rma", 
        "rma.uni"))) {
        if (mod != "1") {
            results <- orchaRd::mod_results(object, mod, group, 
                N, by = by, at = at, weights = weights, upper = upper)
        }
        else {
            results <- orchaRd::mod_results(object, mod = "1", 
                group, N, by = by, at = at, weights = weights, 
                upper = upper)
        }
    }
    if (any(class(object) %in% c("orchard"))) {
        results <- object
    }
    mod_table <- results$mod_table
    data_trim <- results$data
    data_trim$moderator <- factor(data_trim$moderator, levels = mod_table$name, 
        labels = mod_table$name)
    data_trim$scale <- (1/sqrt(data_trim[, "vi"]))
    legend <- "Precision (1/SE)"
    if (!is.null(tree.order) & length(tree.order) != nlevels(data_trim[, 
        "moderator"])) {
        stop("Length of 'tree.order' does not equal number of categories in moderator")
    }
    if (!is.null(tree.order)) {
        data_trim$moderator <- factor(data_trim$moderator, levels = tree.order, 
            labels = tree.order)
        mod_table <- mod_table %>% dplyr::arrange(factor(name, 
            levels = tree.order))
    }
    if (is.null(N) == FALSE) {
        data_trim$scale <- data_trim$N
        legend <- paste0("Sample Size ($\\textit{N}$)")
    }
    if (transfm == "tanh") {
        cols <- sapply(mod_table, is.numeric)
        mod_table[, cols] <- Zr_to_r(mod_table[, cols])
        data_trim$yi <- Zr_to_r(data_trim$yi)
        label <- xlab
    }
    if (transfm == "invlogit") {
        cols <- sapply(mod_table, is.numeric)
        mod_table[, cols] <- lapply(mod_table[, cols], function(x) metafor::transf.ilogit(x))
        data_trim$yi <- metafor::transf.ilogit(data_trim$yi)
        label <- xlab
    }
    if (transfm == "percentr") {
        cols <- sapply(mod_table, is.numeric)
        mod_table[, cols] <- lapply(mod_table[, cols], function(x) (exp(x) - 
            1) * 100)
        data_trim$yi <- (exp(data_trim$yi) - 1) * 100
        label <- xlab
    }
    if (transfm == "percent") {
        cols <- sapply(mod_table, is.numeric)
        mod_table[, cols] <- lapply(mod_table[, cols], function(x) exp(x))
        data_trim$yi <- (exp(data_trim$yi))
        label <- xlab
    }
    else {
        label <- xlab
    }
    mod_table$K <- as.vector(by(data_trim, data_trim[, "moderator"], 
        function(x) length(x[, "yi"])))
    mod_table$g <- as.vector(num_studies(data_trim, moderator, 
        stdy)[, 2])
    group_no <- length(unique(mod_table[, "name"]))
    cbpl <- c("grey69", 
                 "grey69", 
                 "grey69",
                 "grey69", 
                 "grey69", 
                 "grey69", 
                 "grey69", 
                 "grey69"
)
    if (colour == TRUE) {
        color <- as.factor(data_trim$stdy)
        color2 <- NULL
    }
    else {
        color <- data_trim$mod
        color2 <- mod_table$name
    }
    if (fill == TRUE) {
        fill <- color
    }
    else {
        fill <- NULL
    }
    if (names(mod_table)[2] == "condition") {
        condition_no <- length(unique(mod_table[, "condition"]))
        plot <- ggplot2::ggplot() + ggbeeswarm::geom_quasirandom(data = data_trim, 
            ggplot2::aes(y = yi, x = moderator, size = scale, 
                colour = color, fill = fill), alpha = alpha, 
            shape = 21) + ggplot2::geom_hline(yintercept = 1, 
            linetype = 2, colour = "red", alpha = 1) + 
            ggplot2::geom_linerange(data = mod_table, ggplot2::aes(x = name, 
                ymin = lowerCL, ymax = upperCL), size = branch.size, 
                position = ggplot2::position_dodge2(width = 0.3)) + 
            ggplot2::geom_pointrange(data = mod_table, ggplot2::aes(y = estimate, 
                x = name, ymin = lowerPR, ymax = upperPR, shape = as.factor(condition), 
                fill = color2), fill = "red", size = trunk.size, position = ggplot2::position_dodge2(width = 0.3), 
                linewidth = twig.size) + ggplot2::scale_shape_manual(values = 20 + 
            (1:condition_no)) + ggplot2::theme_bw() + ggplot2::guides(fill = "none", 
            colour = "none") + ggplot2::theme(legend.position = c(0, 
            1), legend.justification = c(0, 1)) + ggplot2::theme(legend.title = ggplot2::element_text(size = 9)) + 
            ggplot2::theme(legend.direction = "horizontal") + 
            ggplot2::theme(legend.background = ggplot2::element_blank()) + 
            ggplot2::labs(y = label, x = "", size = latex2exp::TeX(legend)) + 
            ggplot2::labs(shape = condition.lab) + ggplot2::theme(axis.text.y = ggplot2::element_text(size = 10, 
            colour = "black", hjust = 0.5, angle = angle))
        if (flip) {
            plot <- plot + ggplot2::coord_flip()
        }
    }
    else {
        plot <- ggplot2::ggplot() + ggbeeswarm::geom_quasirandom(data = data_trim, 
            ggplot2::aes(y = yi, x = moderator, size = scale, 
                colour = color, fill = fill), alpha = alpha, 
            shape = 21) + ggplot2::geom_hline(yintercept = 1, 
            linetype = 2, colour = "red", alpha = 1) + 
            ggplot2::geom_linerange(data = mod_table, ggplot2::aes(x = name, 
                ymin = lowerCL, ymax = upperCL), size = branch.size) + 
            ggplot2::geom_pointrange(data = mod_table, ggplot2::aes(y = estimate, 
                x = name, ymin = lowerPR, ymax = upperPR, fill = color2), fill = "red",
                size = trunk.size, linewidth = twig.size, shape = 21) + 
            ggplot2::theme_bw() + ggplot2::guides(fill = "none", 
            colour = "none") + ggplot2::theme(legend.title = ggplot2::element_text(size = 9)) + 
            ggplot2::theme(legend.direction = "horizontal") + 
            ggplot2::theme(legend.background = ggplot2::element_blank()) + 
            ggplot2::labs(y = label, x = "", size = latex2exp::TeX(legend)) + 
            ggplot2::theme(axis.text.y = ggplot2::element_text(size = 10, 
                colour = "black", hjust = 0.5, angle = angle))
        if (flip) {
            plot <- plot + ggplot2::coord_flip()
        }
    }
    if (legend.pos == "bottom.right") {
        plot <- plot + ggplot2::theme(legend.position = c(1, 
            0), legend.justification = c(1, 0))
    }
    else if (legend.pos == "bottom.left") {
        plot <- plot + ggplot2::theme(legend.position = c(0, 
            0), legend.justification = c(0, 0))
    }
    else if (legend.pos == "top.right") {
        plot <- plot + ggplot2::theme(legend.position = c(1, 
            1), legend.justification = c(1, 1))
    }
    else if (legend.pos == "top.left") {
        plot <- plot + ggplot2::theme(legend.position = c(0, 
            1), legend.justification = c(0, 1))
    }
    else if (legend.pos == "top.out") {
        plot <- plot + ggplot2::theme(legend.position = "top")
    }
    else if (legend.pos == "bottom.out") {
        plot <- plot + ggplot2::theme(legend.position = "bottom")
    }
    else if (legend.pos == "none") {
        plot <- plot + ggplot2::theme(legend.position = "none")
    }
    if (cb == TRUE) {
        plot <- plot + ggplot2::scale_fill_manual(values = cbpl) + 
            ggplot2::scale_colour_manual(values = cbpl)
    }
    if (k == TRUE && g == FALSE && k.pos == "right") {
        plot <- plot + ggplot2::annotate("text", y = (max(data_trim$yi) + 
            (max(data_trim$yi) * 0.1)), x = (seq(1, group_no, 
            1) + 0.3), label = paste("italic(k)==", mod_table$K[1:group_no]), 
            parse = TRUE, hjust = "right", size = 5)
    }
    else if (k == TRUE && g == FALSE && k.pos == "left") {
        plot <- plot + ggplot2::annotate("text", y = (min(data_trim$yi) + 
            3), x = (seq(1, group_no, 
            1) + 0.3), label = paste("italic(k)==", mod_table$K[1:group_no]), 
            parse = TRUE, hjust = "left", size = 5)
    }
    else if (k == TRUE && g == TRUE && k.pos == "right") {
        plot <- plot + ggplot2::annotate("text", y = (max(data_trim$yi) + 
            (max(data_trim$yi) * 0.1)), x = (seq(1, group_no, 
            1) + 0.3), label = paste("italic(k)==", mod_table$K[1:group_no], 
            "~", "(", mod_table$g[1:group_no], ")"), parse = TRUE, 
            hjust = "right", size = 5)
    }
    else if (k == TRUE && g == TRUE && k.pos == "left") {
        plot <- plot + ggplot2::annotate("text", y = (min(data_trim$yi) + 
            3), x = (seq(1, group_no, 
            1) + 0.3), label = paste("italic(k)==", mod_table$K[1:group_no], 
            "~", "(", mod_table$g[1:group_no], ")"), parse = TRUE, 
            hjust = "left", size = 5)
    }
    else if (k == TRUE && g == FALSE && k.pos %in% c("right", 
        "left", "none") == FALSE) {
        plot <- plot + ggplot2::annotate("text", y = k.pos, x = (seq(1, 
            group_no, 1) + 0.3), label = paste("italic(k)==", 
            mod_table$K[1:group_no]), parse = TRUE, size = 5)
    }
    else if (k == TRUE && g == TRUE && k.pos %in% c("right", 
        "left", "none") == FALSE) {
        plot <- plot + ggplot2::annotate("text", y = k.pos, x = (seq(1, 
            group_no, 1) + 0.3), label = paste("italic(k)==", 
            mod_table$K[1:group_no], "~", "(", mod_table$g[1:group_no], 
            ")"), parse = TRUE, size = 5)
    }
    return(plot)
}
```

# Customized functions

The following code defines a standardized function to fit multivariate meta-analytic models. We are going to use this function to run all single-moderator models below.

```{r}
run_model <- function(data, formula){
  data <- as.data.frame(data) # convert data set into a data frame to calculate VCV matrix 
  VCV <- impute_covariance_matrix(data$ln_TMF_se^2,
                                  cluster = data$FW_ID, 
                                  r = 0.5) # create VCV matrix for the specified data
  rma.mv(ln_TMF,
         VCV,
         mods = formula,
         random = list(~1|Study_ID, 
                       ~1|FW_ID, 
                       ~1|PFAS_ID, 
                       ~1|TMF_ID
                       ),
         test = "t",
         data = data,
         sparse = TRUE)
}
```

# Intercept meta-analytic model

Determine the random effect structure:
The random effects model accounts for between-study heterogeneity, which reflects the variability in effect sizes across the studies being analyzed. In determining the random effect structure, we aim to identify the sources of this heterogeneity and quantify its extent within the data. This step is crucial for accurately modeling the variation and ensuring that the results are generalizable beyond the specific studies included in the analysis.

--> **NOTE!** Model outputs are on the natural log scale (ln TMF), whereas the plots on the original scale (TMF).
```{r, eval=FALSE, include=TRUE}
mod <- rma.mv(yi = ln_TMF, # Natural logarithm of the Trophic Magnification Factor
              V = VCV, # Variance co-variance matrix
              random = list(~1|Study_ID, # Between-study effect
                            ~1|FW_ID, # Between food webs effect
                            ~1|PFAS_ID, # Between type of PFAS effect
                            ~1|TMF_ID # Within-study effect
                            ),
              test = "t", 
              sparse = T,
              data = TMF_data2)

save(mod, file = here("Rdata", "mod.RData"))
```

```{r, warning=FALSE, echo=FALSE}
load(here("RData", "mod.RData"))
tab_mod <-readRDS(here("Rdata", "tab_mod.RDS"))
summary(mod)
i2_ml(mod)

I2 <- orchaRd::i2_ml(mod)
ma1 <- orchard_plot_new(mod,
                        transfm = "percent",
                        mod = "1",
                        group = "Study_ID", 
                        xlab = "ln_TMF",
                        k.pos = "left",
                        alpha = 0.6,
                        trunk.size = 1.5,
                        branch.size = 2.7,
                        twig.size = 0.4,
                        colour = FALSE,
                        fill = FALSE) +  
  annotate(geom = "text",
           x = 1.3,
           y = 7.5, 
           label = paste0("italic(I)^{2} == ", round(I2[1],4)),
           size = 6,
           color ="black",
           parse = TRUE) +
  scale_size_continuous(range = c(1, 10)) + # change point scaling
  theme(panel.border = element_rect(colour = "black", 
                                    fill = NA,
                                    size = 1.3), # border around the plot
        plot.title = element_text(face = "bold", size = 17),
       legend.title = element_text(size = 15),
        legend.text = element_text(size = 14),
        axis.title.x = element_text(size = 17),
        axis.title.y = element_text(size = 17),
        axis.text.y = element_blank(),
       axis.text.x = element_text(size = 16)) +
  #ylim(NA, 10) +
  xlab("Intercept") +
  ylab("TMF") +
  ggtitle("A") +
  scale_y_continuous(limits = c(0, 10), breaks = seq(0, 10, by = 1))


ma1
```

```{r, echo=FALSE, eval=FALSE}
ggsave(here("figs","overall.png"),
       width = 8,
       height = 4)
```

The red dotted line represents TMF = 1, the threshold indicating trophic magnification when exceeded, and biodilution when below.
Next, we'll plot the same graph with a zoomed-in view to enhance the visual interpretation of the results. (Note: The maximum value on the x-axis is equal to 10).

```{r, warning=FALSE, echo=FALSE}
ma2 <- orchard_plot_new(mod,
                        transfm="percent",
                        mod = "1",
                        group = "Study_ID", 
                        xlab = "ln_TMF",
                        alpha = 1.2,
                        trunk.size = 1.2,
                        branch.size = 2.5,
                        twig.size = 0.3,
                        k.pos = "left",
                        colour = FALSE,
                        fill = FALSE) + 
  scale_size_continuous(range = c(1, 7)) + # change point scaling
  theme(panel.border = element_rect(colour = "black", 
                                    fill=NA,
                                    size=1.3), # border around the plot
        text = element_text(size = 11), # change font sizes
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 9),
        axis.text.y = element_blank() ,
  axis.text.x = element_text(size = 10)) +
  xlab("Intercept") +
  ylab("TMF") +
  ylim(NA, 10)

ma2
```

Our model shows that the overall PFAS Trophic Magnification Factor (TMF) is 2 (95% CI: 1.63-2.45), which is statistically significantly greater than 1. This indicates that, on average, PFAS) biomagnify within food webs by a factor of 2.
A TMF of 2 means that the concentration of PFAS doubles with each increase in trophic level.

# Subcategory meta-regression analysis

```{r, echo=FALSE}
TMF_data3 <- TMF_data2 %>% 
  filter(!PFAS_ID %in% c("ΣPFAS", "ΣPFCA", "ΣPFSA", "ΣPFCs", "PFODA")) %>%  # PFODA removed because NA
  #filter(n_distinct(Study_ID) > 1) %>%
  ungroup() %>%
  mutate(PFAS_ID = case_when(
    PFAS_ID == "6:2 Cl-PFESA" ~ "F-53B",
    PFAS_ID == "8:2 Cl-PFESA" ~ "F-53B",
    PFAS_ID == "F53B" ~ "F-53B",
    TRUE ~ PFAS_ID
  ))

k_n_data <- TMF_data3 %>% 
  group_by(PFAS_ID) %>%
  arrange(PFAS_ID) %>% 
  summarise(k = n(), n = length(unique(Study_ID)))
```

```{r, eval=FALSE, include=TRUE}
VCV_chem <- vcalc(vi = ln_TMF_se^2,
                  cluster = FW_ID, 
                  obs = TMF_ID,
                  subgroup = PFAS_ID, 
                  rho = 0.5,
                  data = TMF_data3)


mod_chem <- rma.mv(ln_TMF ~ PFAS_ID - 1,
                   V = VCV_chem,
                   random = list(~ PFAS_ID | FW_ID), 
                   struct = "DIAG",
                   test = "t",
                   sparse = T,
                   data = TMF_data3,
                   #verbose = TRUE, 
                   control=list(iter.max=1000, 
                                rel.tol=1e-8))
# Save the model
save(mod_chem, file = here("Rdata", "mod_chem.RData"))
# Save the table
write.csv(TMF_data3, here("data/TMF_data3.csv"), row.names = FALSE)
```

```{r, warning=FALSE, echo=FALSE}
load(here("RData", "mod_chem.RData"))
summary(mod_chem)

res_tab2 <- broom::tidy(mod_chem)
res_tab2$ci.lb <- mod_chem$ci.lb
res_tab2$ci.ub <- mod_chem$ci.ub
res_tab2$pval <-mod_chem$pval
res_tab2 <- res_tab2 %>% 
  mutate(
    PFAS_ID = str_remove(term, "^PFAS_ID"),  # Remove 'PFAS_ID1: ' prefix
    estimate = exp(estimate),  # Convert estimates back to original scale
    ci.lb = exp(ci.lb),  # Convert lower CI back to original scale
    ci.ub = exp(ci.ub)   # Convert upper CI back to original scale
  ) %>% 
  arrange(PFAS_ID)

res_tab2 <- res_tab2 %>% 
  mutate(k = k_n_data$k) %>% 
  mutate(n = k_n_data$n)

# Prepare the data for plotting and order PFAS_ID by estimate value
plot_data2 <- res_tab2 %>%
  as.data.frame() %>% 
  filter(k > 10) %>% 
  arrange(estimate)

# Create the flipped forest plot
forest_plot2 <- ggplot(plot_data2, aes(y = reorder(PFAS_ID, estimate), x = estimate)) +
  geom_point(aes(size = k),  # Make point size proportional to k
             color = ifelse(plot_data2$pval > 0.05, "grey", "black"),  # You can change the color if desired
             alpha = 1) +  # Add transparency for better visibility 
  scale_size(range = c(5, 13)) + # Set minimum size to 3 and maximum to 6
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub), 
                 height = 0.2,
                 alpha = ifelse(plot_data2$pval > 0.05, 0.6, 1)) +  # Horizontal error bars
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +  # Reference line at 1
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = -0.18),
            hjust = 0, size = 6, # Add k values as text next to the points
            fontface = ifelse(plot_data2$pval < 0.05, "bold", "plain")) +  # Access pval outside aes()
  # Add "*" next to PFUnDA and PFNA
  # geom_text(data = subset(plot_data2, PFAS_ID %in% c("PFUnDA", "PFNA", "PFTrDA", "PFDoDA", "FOSA", "PFHxS", "PFDS", "PFTeDA", "PFOA", "PFBA", "PFPeA", "PFHpA", "PFBS", "PFHxA")),
  #           aes(x = -0.21, label = "*"), size = 9, color = "black") +
  # geom_text(data = subset(plot_data2, PFAS_ID %in% c("PFUnDA", "PFNA", "PFTrDA", "PFDoDA", "FOSA", "PFHxS", "PFDS", "PFTeDA", "PFOA", "PFBA", "PFPeA", "PFHpA", "PFBS", "PFHxA")),
  #           aes(x = ci.lb, label = "*"),
  #           hjust = 1.2, vjust = 0.7, size = 6, color = "black") +
  xlab("TMF") +
  ylab("PFAS") +
  ggtitle("B") +
  theme_minimal() +  # Use a minimal theme
  theme(legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1),
         plot.title = element_text(face = "bold", size = 16),
       legend.title = element_text(size = 15),
        legend.text = element_text(size = 14),
        axis.title.x = element_text(size = 17),
        axis.title.y = element_text(size = 17),
        axis.text.y = element_text(size = 16),
       axis.text.x = element_text(size = 16)) +  
   #scale_x_break(c(4, 6)) +
   scale_x_continuous(breaks = seq(0, 4, by = 1), limits = c(-0.21, 4))
  
forest_plot2
```

```{r, eval=FALSE, echo=FALSE}
# Combine plots with specified heights
combined_plot <- ma1 / forest_plot2 + 
  plot_layout(heights = c(1, 4))  # ma1 takes 1 part, forest_plot2 takes 2 parts

# Save the combined plot
ggsave(here("figs", "fig1.png"), plot = combined_plot, width = 16, height = 11, dpi = 300)

```

Now, we have a look to all chemicals regardless of the number of effect sizes.

```{r}
plot_data3 <- res_tab2 %>%
  as.data.frame() %>% 
  arrange(estimate)

# Create the flipped forest plot
forest_plot3 <- ggplot(plot_data3, aes(y = reorder(PFAS_ID, estimate), x = estimate)) +
  geom_point(aes(size = k),  # Make point size proportional to k
             color = ifelse(plot_data3$pval > 0.05, "grey", "black"),  # You can change the color if desired
             alpha = 1) +  # Add transparency for better visibility 
  scale_size(range = c(3, 7)) + # Set minimum size to 3 and maximum to 6
  geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub), 
                 height = 0.2,
                 alpha = ifelse(plot_data3$pval > 0.05, 0.6, 1)) +  # Horizontal error bars
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +  # Reference line at 1
  geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = -1.7),
            hjust = 0, size = 3.5, # Add k values as text next to the points
            fontface = ifelse(plot_data3$pval < 0.05, "bold", "plain")) +  # Access pval outside aes()
  xlab("TMF") +
  ylab("PFAS") +
  theme_minimal() +  # Use a minimal theme
  theme(axis.text.y = element_text(size = 10),  # Adjust y-axis text size
        axis.text.x = element_text(size = 10),  # Adjust x-axis text size
        #axis.text.x.top = element_blank(),  # Remove x-axis labels from the top
        axis.title = element_text(size = 11),
        legend.position = "none",
        panel.border = element_rect(colour = "black", fill = NA, size = 1)) +  
  scale_x_break(c(13, 18)) +
  scale_x_break(c(19.4, 23)) +
  scale_x_continuous(breaks = c(seq(0, 13, by = 1), seq(18, 19, by = 1), seq(23, 25, by = 1)),
                     limits = c(-1.7, 25))  # Combine breaks
  
forest_plot3
```

```{r, eval=FALSE}
# Save the  plot
ggsave(here("figs/supplements", "forest_plot.png"), plot = forest_plot3, width = 9, height = 14, dpi = 300)
```

## Simpler model
Let's run a few simpler models to see if what one has the lowest AICc value (better fit).
In this model, Here, ~ 1 | PFAS_ID and ~ 1 | FW_ID specifies independent random intercepts for PFAS_ID and FW_ID. This structure does not allow for varying slopes but instead models each PFAS_ID and each FW_ID with separate random intercepts, treating them independently.

```{r, eval=FALSE}
mod_chem2 <- rma.mv(ln_TMF ~ PFAS_ID - 1,
                     V = VCV_chem,
                     random = list(~ 1|PFAS_ID,
                                   ~ 1|FW_ID), 
                     struct = "DIAG",
                     est = "t",
                     sparse = T,
                     data = TMF_data3,
                     #verbose = TRUE, 
                     control=list(iter.max=1000, 
                                  rel.tol=1e-8))

# Save the model
save(mod_chem2, file = here("Rdata", "mod_chem2.RData"))
```

```{r}
load(here("RData", "mod_chem2.RData"))
summary(mod_chem2)
```

While mod_chem has more variance components and hence a greater risk of overfitting, the lower AICc (mod_chem = 4122 and mod_chem2 = 6731) suggests that the additional complexity is justified by the improved fit to the data. This indicates that mod_chem is likely capturing meaningful interaction variability between PFAS_ID and FW_ID that mod_chem2 does not account for, making it a better model for these data despite having more parameters.

## PFOS reference - Comparison model
We are going to compare each compound against PFOS (the compound with the largest effect size and sample size). By doing so, we can assess what compounds have a mean estimate lower than PFOS.

```{r}
TMF_data3$PFAS_ID <- factor(TMF_data3$PFAS_ID)
# Relevel PFAS_ID so that PFOS is the reference level
TMF_data3$PFAS_ID <- relevel(TMF_data3$PFAS_ID, ref = "PFOS")
```

```{r, eval=FALSE}
# Fit the model
mod_chem_contr <- rma.mv(ln_TMF ~ PFAS_ID,
                   V = VCV_chem,
                   random = list(~ PFAS_ID | FW_ID), 
                   struct = "DIAG",
                   test = "t",
                   sparse = TRUE,
                   data = TMF_data3,
                   control = list(iter.max = 1000, 
                                  rel.tol = 1e-8))

# Save the model
save(mod_chem_contr, file = here("Rdata", "mod_chem_contr.RData"))
```

```{r}
load(here("RData", "mod_chem_contr.RData"))
summary(mod_chem_contr)
```

## Means for (un)regulated compounds

```{r}
# Regulation levels
lacking <- c("6:2ClPFESA", "PFDS", "PFBA", "PFPeA","PFHxA")
regulated <- c("PFDA", "PFUnDA", "PFTrDA", "PFDoDA", "PFTeDA", "PFHpA", "PFBS")
strong <- c("PFOS", "br-PFOS", "l-PFOS", "PFNA", "FOSA", "PFHxS", "PFOA")

plot_data4 <- TMF_data2

# Add the regulation column based on PFAS_ID
plot_data4$regulation <- ifelse(plot_data4$PFAS_ID %in% lacking, "unregulated",
                          ifelse(plot_data4$PFAS_ID %in% regulated, "regulated",
                          ifelse(plot_data4$PFAS_ID %in% strong, "strongly regulated", NA)))

plot_data4$regulation <- factor(plot_data4$regulation, levels = c("unregulated", "regulated", "strongly regulated"))

# Remove rows where the regulation column is NA
plot_data4 <- plot_data4 %>% filter(!is.na(regulation))
```

```{r, eval=FALSE}
regulation_model <- run_model(plot_data4, ~ regulation)
save(regulation_model, file = here("Rdata", "regulation_model.RData"))
```

```{r}
load(here("RData", "regulation_model.RData"))
summary(regulation_model)
r2_regulation <- r2_ml(regulation_model, plot_data4)
```

```{r}
# k_n_data2 <- plot_data4 %>% 
#   group_by(regulation) %>%
#   arrange(regulation) %>% 
#   summarise(k = n(), n = length(unique(Study_ID)))
# 
# res_tab3 <- broom::tidy(regulation_model)
# res_tab3$ci.lb <- regulation_model$ci.lb
# res_tab3$ci.ub <- regulation_model$ci.ub
# res_tab3$pval <-regulation_model$pval
# res_tab3 <- res_tab3 %>% 
#   mutate(
#     regulation = str_remove(term, "^regulation"),
#     estimate = exp(estimate),  # Convert estimates back to original scale
#     ci.lb = exp(ci.lb),  # Convert lower CI back to original scale
#     ci.ub = exp(ci.ub)   # Convert upper CI back to original scale
#   ) %>% 
#   arrange(estimate) %>% 
#   mutate(k = k_n_data2$k) %>% 
#   mutate(n = k_n_data2$n)
# 
# 
# forest_plot4 <- ggplot(res_tab3, aes(y = reorder(regulation, estimate), x = estimate)) +
#   geom_point(aes(size = k),
#              color = ifelse(res_tab3$pval > 0.05, "grey", "black"),  
#              alpha = 1) +  
#   scale_size(range = c(8, 16)) + 
#   geom_errorbarh(aes(xmin = ci.lb, xmax = ci.ub), 
#                  height = 0.2,
#                  alpha = ifelse(res_tab3$pval > 0.05, 0.6, 1)) +  
#   geom_vline(xintercept = 1, linetype = "dashed", color = "red") +  
#   geom_text(aes(label = paste0("k = ", k, " (", n, ")"), x = 0),
#             hjust = 0, size = 5, 
#             fontface = ifelse(res_tab3$pval < 0.05, "bold", "plain")) +
#   xlab("TMF") +
#   ylab("PFAS") +
#   #theme_minimal() +  
#   theme(axis.text.y = element_text(size = 12),  
#         axis.text.x = element_text(size = 12),  #
#         #axis.text.x.top = element_blank(),  
#         axis.title = element_text(size = 13),
#         legend.position = "none",
#         panel.border = element_rect(colour = "black", fill = NA, size = 1)) +  
#   scale_x_continuous(breaks = c(seq(0, 4, by = 1)),
#                      limits = c(0, 4))
#   
# forest_plot4
```

```{r}
fig_regulation <- orchard_plot_new(regulation_model,
             transfm = "percent",
             mod = "regulation",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 3.4,
           y = 8, 
           label = paste0("italic(R)^{2} == ", round(r2_regulation[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(#plot.title = element_text(face = "bold", size = 16),
       legend.title = element_text(size = 13),
        legend.text = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 13),
       axis.text.x = element_text(size = 13)) +
  #ggtitle("C") +
  xlab("PFAS class") +
  ylab("TMF") +
  #scale_y_break(c(11, 13)) +
  scale_y_continuous(limits = c(0, 11), breaks = seq(0, 11, by = 1))

fig_regulation
```

```{r, eval=FALSE}
ggsave(here("figs/supplements", "regulation.png"), plot = fig_regulation, width = 14, height = 5, dpi = 300)
```


# World map location of food webs

```{r}
# Formatting coordinates

coords <- fw_data %>%
  # Round Latitude and Longitude
  mutate(
    Latitude = round(Latitude_DD, 0),  
    Longitude = round(Longitude_DD, 0)
  ) %>%
  # group_by(Latitude_DD, Longitude_DD, Ecosystem) %>%
  # reframe(
  #   count_FW = n(),  # Count how many FW_IDs share the same (rounded) Latitude and Longitude
  # ) %>%
  # rename(
  #   Latitude = Latitude_DD,
  #   Longitude = Longitude_DD
  # ) %>% 
  mutate(
    Ecosystem = fct_recode(Ecosystem,
                           "estuarine/brackish/tidal" = "estuarine",
                           "estuarine/brackish/tidal" = "brackish",
                           "estuarine/brackish/tidal" = "tidal"))


# Load the world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

# Plot the map with clusters and counts
w_map <- ggplot(data = world) +
  geom_sf(fill = "grey97") +  # Plot the world map
  geom_jitter(data = coords, aes(x = Longitude, y = Latitude, color = Ecosystem, alpha = 0.7), size = 3, width = 1.2, height = 1.2) + 
  theme(
    panel.background = element_rect(fill = "white"),  
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),  
    axis.title.x = element_text(size = 14), 
    axis.title.y = element_text(size = 14),  
    panel.border = element_rect(colour = "black", fill = NA, size = 1),
    plot.margin = margin(t = 10, r = 10, b = 5, l = 5),
    legend.position = "bottom",  # Move the legend to the bottom
    legend.direction = "horizontal",  # Display the legend horizontally
    legend.background = element_rect(fill = "transparent", color = NA),
    legend.key = element_rect(fill = "transparent", color = NA),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 13)) +
  guides(size = "none", alpha = "none", color = guide_legend(ncol = 6, override.aes = list(size = 4))) +
  scale_color_manual(values = c("#114B5F", "#FB8B24", "#597802", "#66101F")) +
  labs(color = "Ecosystem type:")

w_map
```

```{r, echo=FALSE, eval=FALSE}
# Save the  plot
ggsave(here("figs", "world_map.png"), plot = w_map, width = 11, height = 6, dpi = 300)
```

# Single-moderator meta-regression models

In our meta-analysis, we have 4 categories of predictors:

-  Predictors belonging to the **research methods**.
-  Predictors belonging to the **geographical location** of food webs.
-  Predictors belonging to the **biological and ecological characteristics of food webs**.
-  **PFAS characteristics**.

## Research methods

### **Sample type: whole-organism or organ/tissue-specific analysis**

Whole-organism concentrations are usually measured at the base of food webs (plankton, lichens). For animals of higher trophic levels (seals, bears etc.) practical and ethical reasons mean sampling is done on specific organs or fluids instead. The sampling strategy also pertains to whether the data was initially gathered due to a study's focus on ecological risk (whole animals) or human health risk (emphasizing edible parts such as fillets, eggs, muscle tissue, etc.).

We predict that PFAS biomagnification estimates based exclusively on whole-organism samples may differ from those on a mix of whole-organism and organ-specific.
```{r}
TMF_data2 <- TMF_data2 %>% 
  mutate(Sample_type = recode(
    Sample_type,
    "specific tissues and whole-organisms" = "mixed"
  ))
```

```{r, eval=FALSE}
sum(is.na(TMF_data2$Sample_type)) #checking the amount of NAs
#[1] 0
sample_model <- run_model(TMF_data2, ~ Sample_type)
save(sample_model, file = here("Rdata", "sample_model.RData"))
```

```{r, echo=FALSE, warning=FALSE, fig.cap="Note: Maximum TMF value set to 10"}
load(here("RData", "sample_model.RData"))
summary(sample_model)
r2_sample <- r2_ml(sample_model, TMF_data2)

fig_sample <- orchard_plot_new(sample_model,
                           transfm="percent",
             mod = "Sample_type",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             alpha = 1,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 3.4,
           y = 9, 
           label = paste0("italic(R)^{2} == ", round(r2_sample[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  theme(plot.title = element_text(face = "bold", size  = 16),
       legend.title = element_text(size = 13),
        legend.text = element_text(size = 12),
        #axis.title.x = element_text(size = 12),
       axis.title.x = element_blank(),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 13),
       axis.text.x = element_blank()) +
  xlab("Samples type") +
  #ylab("TMF") +
  ggtitle("A") +
  scale_y_continuous(limits = c(0, 14), breaks = seq(0, 14, by = 1))

fig_sample
```

```{r, echo=FALSE, eval=FALSE}
ggsave(here("figs","sample.png"),
       width = 8,
       height = 6)
```

Note: The maximum TMF value in the figure is capped at 10 to enhance the visual clarity of the results.

TMFs estimated using both tissue-specific samples (e.g., liver, blood) and whole-organism samples are **significantly higher by 49%** (p = 0.0001; 95% CI: 21-84%) compared to those estimated using only whole-organism samples.

### **Concentration determination method**

Evaluation of biomagnification using TMFs based on protein- or lipid-normalized concentrations in food web organisms has been rarely suggested. However, it should be considered a source of variability in biomagnification estimates.
We predict that the biomagnification estimates of TMFs based on protein- or lipid-normalized PFAS concentrations may differ from those based on concentrations non-normalised.

```{r, include=FALSE}
sum(is.na(TMF_data2$Conc_determ_method))
#[1] 16
TMF_data2_norm <- TMF_data2 %>%
  filter(!is.na(Conc_determ_method) & Conc_determ_method != "")
sum(is.na(TMF_data2_norm$Conc_determ_method))
#[1] 0

TMF_data2_norm <- TMF_data2_norm %>%
  mutate(Conc_determ_method = recode(
    Conc_determ_method,
    "polar lipid equivalent corrected concentrations" = "lw",
    "wet weight concentrations (ww)" = "ww",
    "protein equivalent corrected concentrations (pw)" = "pw",
    "lipid equivalent corrected concentrations (lw)" = "lw",
    "dry weight concentrations (dw)" = "dw",
    "apparent chemical activities corrected concentrations" = "aca",
    "albumin equivalent corrected concentrations" = "aq",
    "fresh weight (fw)" = "fw")) %>%
  group_by(Conc_determ_method) %>%
  filter(n_distinct(Study_ID) > 1) %>%
  ungroup()
```

```{r, eval=FALSE, warning=FALSE}
norm_model <- run_model(TMF_data2_norm, ~ Conc_determ_method - 1)
save(norm_model, file = here("Rdata", "norm_model.RData"))
```

```{r, echo=FALSE, fig.cap="Note: Maximum TMF value set to 12"}
load(here("RData", "norm_model.RData"))
summary(norm_model)
r2_norm <- r2_ml(norm_model, TMF_data2_norm)
   # R2_marginal R2_conditional 
   #  0.05408518     0.89910329 

fig_norm <- orchard_plot_new(norm_model,
                             transfm="percent",
             mod = "Conc_determ_method",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 4.4,
           y = 10, 
           label = paste0("italic(R)^{2} == ", round(r2_norm[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(size = 18),
       legend.title = element_text(size = 11),
        legend.text = element_text(size = 9),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 14),
       axis.text.x = element_text(size = 14)) +
  ylim(NA, 12) +
  ylab("TMF")

fig_norm
```

```{r, echo=FALSE, eval=FALSE}
ggsave(here("figs","norm.png"),
       width = 8,
       height = 5)
```

Normalized concentrations have the lowest estimate (lw = 0.1659 and pw = 0.3846), compared to not normalized concentrations (dw = 0.4633 and ww = 0.7901).
Let's merge these four categories into two categories (normalized and not normalized concentrations).

```{r}
TMF_data2_norm <- TMF_data2_norm %>%
  mutate(Normalization = recode(
    Conc_determ_method,
    "lw" = "Normalized",
    "ww" = "Not normalized",
    "pw" = "Normalized",
    "dw" = "Not normalized"
    ))
```

```{r, eval=FALSE, warning=FALSE}
norm_model2 <- run_model(TMF_data2_norm, ~ Normalization)
save(norm_model2, file = here("Rdata", "norm_model2.RData"))
```

```{r, echo=FALSE, fig.cap="Note: Maximum TMF value set to 10"}
load(here("RData", "norm_model2.RData"))
summary(norm_model2)
r2_norm2 <- r2_ml(norm_model2, TMF_data2_norm)

fig_norm2 <- orchard_plot_new(norm_model2,
                               transfm="percent",
             mod = "Normalization",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             alpha = 1,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 2.4,
           y = 9, 
           label = paste0("italic(R)^{2} == ", round(r2_norm2[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(face = "bold", size  = 16),
       legend.title = element_text(size = 13),
        legend.text = element_text(size = 12),
        #axis.title.x = element_text(size = 12),
       axis.title.x = element_blank(),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 13),
       axis.text.x = element_blank()) +
  xlab("Determination method") +
  #ylab("TMF") +
  ggtitle("B") +
  scale_y_continuous(limits = c(0, 14), breaks = seq(0, 14, by = 1))

fig_norm2
```

```{r, echo=FALSE, eval=FALSE}
ggsave(here("figs","norm2.png"),
       width = 8,
       height = 4)
```

TMFs estimated using non-normalized PFAS concentrations (i.e., not adjusted for protein or lipid content) are **significantly higher by 43%** (p < .0001; 95% CI: 21-70%) compared to those estimated using normalized PFS concentrations.

### Undetected strategy - Limit of Detection (LOD)

The included studies exibited a highly variable choice of strategy on how to treat censored data (data under limit of detection or quantification) so that we could not perform a meta-regression analysis.

```{r, include=FALSE}
TMF_data2_undetected_strategy <- TMF_data2 %>%
  group_by(Censored_data_strategy) %>%
  summarise(
    n_effect_size = n(),
    n_study = n_distinct(Study_ID) 
  ) %>% 
  arrange(desc(n_study))

# Create a flextable
undetected_strategy_table <- flextable(TMF_data2_undetected_strategy)

undetected_strategy_table <- undetected_strategy_table %>%
  set_header_labels(n_effect_size = "Number of TMFs", n_study = "Number of Studies") %>%
  autofit()

# Create a new Word document
doc <- read_docx()

# Add the flextable to the Word document
doc <- body_add_flextable(doc, undetected_strategy_table)
```


```{r, eval=FALSE}
# Save the document
print(doc, target = "Rdata/undetected_strategy_table.docx")
```

Table for meta-regression analysis:
```{r, eval = FALSE}
# Recode the 'Censored_data_strategy' column
TMF_data2_undetected_strategy2 <- TMF_data2 %>%
  mutate(Censored_data_strategy = recode(Censored_data_strategy,
         
    # The limit value divided by two or squared root of two group
    "The LOQ value divided by two" = "Division by two or √2",
    "The MDL value divided by two" = "Division by two or √2",
    "The LOD value divided by two" = "Division by two or √2",
    "The LOD value divided by two or detection frequency multiplied by LOD value or imputation" = "Division by two or √2",
    "The LOD value divided by the square root of two" = "Division by two or √2",
    "The LOD value divided by the square root of two for values < LOD. The LOQ value divided by two for values < LOQ." = "Division by two or √2",
    "The LOQ value divided by the square root of two" = "Division by two or √2",
    
    # Substitution with zero group
    "Zero for values < LOD" = "Substitution with zero",
    "Zero for undetected. The MDL value divided by two for values < MDL." = "Substitution with zero",
    "Zero for values < LOD. The LOQ value divided by the square root of two for values < LOQ." = "Substitution with zero",
    "Zero for values < LOD. The LOQ value divided by two for values < LOQ." = "Substitution with zero",
    "Zero for values < LOQ. The LOD value divided by two for values < LOD." = "Substitution with zero",
    
    # Exclusion of data group
    "Exclusion of data if values were < LOD." = "Exclusion of data",
    "Exclusion of data if values were < LOQ." = "Exclusion of data",
    "Exclusion of data if values were < MDL." = "Exclusion of data",
    "Exclusion of values < LOD. The LOQ value divided by two for values < LOQ." = "Exclusion of data",
    
    # Others group
    "Imputation method" = "Others",
    "Models accounting for values below the LOD." = "Others",
    "Three method comparison" = "Others",
    
    # Random numbers group
    "Random numbers below half of the MDL" = "Random numbers",
    "Random numbers between 0 and the LOD value" = "Random numbers",
    "Random numbers between 0 and the LOD value divided by two" = "Random numbers",
    "Random numbers between 0 and the MDL value" = "Random numbers",
    
  )) %>% 
  mutate(Censored_data_strategy = fct_relevel(Censored_data_strategy, 
                                              "Division by two or √2")) %>% 
  filter(Censored_data_strategy != "Not provided") %>% 
  group_by(Censored_data_strategy) %>%
  mutate(
    n_effect_size = n(),
    n_study = n_distinct(Study_ID) 
  ) %>% 
  arrange(desc(n_study))
```

```{r, eval=FALSE}
undetected_model <- run_model(TMF_data2_undetected_strategy2, ~ Censored_data_strategy)
save(undetected_model, file = here("Rdata", "undetected_model.RData"))
```

```{r, echo=FALSE, fig.cap="Note: Maximum TMF value set to 10"}
load(here("RData", "undetected_model.RData"))
summary(undetected_model)
r2_lod <- r2_ml(undetected_model, TMF_data2_undetected_strategy2)

fig_lod <- orchard_plot_new(undetected_model,
             transfm="percent",
             mod = "Censored_data_strategy",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 5.4,
           y = 9,
           label = paste0("italic(R)^{2} == ", round(r2_lod[1],4)),
           color ="black",
           parse = TRUE,
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(face = "bold", size  = 16),
       legend.title = element_text(size = 13),
        legend.text = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 13),
       axis.text.x = element_text(size = 13)) +
  xlab("Treatment of undetected values") +
  ylab("TMF") +
  ggtitle("D") +
  scale_y_continuous(limits = c(0, 14), breaks = seq(0, 14, by = 1))

fig_lod
```

### N-isotope trophic enrichment factor (TEF)

Different studies use different N-isotope TEF to calculate the trophic level of species. The choice of TEF can affect the resulting TMF.
We predict that different TEF choices can result in under- or overestimation of PFAS biomagnification.

```{r, include=FALSE}
sum(is.na(TMF_data2$TEF))
#[1] 98
TMF_data2_tef <- TMF_data2[complete.cases(TMF_data2[ , "TEF"]),]

TMF_data2_tef <- TMF_data2 %>%
  filter(!is.na(TEF) & TEF != "") %>%
  group_by(TEF) %>%
  filter(n_distinct(Study_ID) > 1) %>%
  ungroup()

sum(is.na(TMF_data2_tef$TEF))
#[1] 0
```

```{r, eval=FALSE}
tef_model <- run_model(TMF_data2_tef, ~ TEF)
save(tef_model, file = here("Rdata", "tef_model.RData"))
```

```{r, echo=FALSE, fig.cap="Note: Maximum TMF value set to 12"}
load(here("RData", "tef_model.RData"))
summary(tef_model)
r2_tef <- r2_ml(tef_model, TMF_data2_tef)
   # R2_marginal R2_conditional 
   #  0.04538842     0.88832187 

fig_tef <- orchard_plot_new(tef_model,
                            transfm="percent",
             mod = "TEF",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 4.4,
           y = 9, 
           label = paste0("italic(R)^{2} == ", round(r2_tef[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(face = "bold", size  = 16),
        legend.title = element_text(size = 13),
        legend.text = element_text(size = 12),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 13),
       axis.text.x = element_blank()) +
  xlab("Trophic Enrichment Factor") +
  ylab("TMF") +
  ggtitle("C") +
  scale_y_continuous(limits = c(0, 14), breaks = seq(0, 14, by = 1))

fig_tef
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","tef.png"),
       width = 8,
       height = 5)
```

```{r, eval=FALSE, echo=FALSE}
# Combine plots with specified heights
figX <- (fig_sample / fig_norm2) + fig_tef + fig_lod +
  plot_layout(heights = c(1.5, 1, 1.8, 2))

# Save the combined plot
ggsave(here("figs", "figX.png"), plot = figX, width = 16, height = 12, dpi = 300)

```

We did not find significant differences between groups. According to the single-moderator regression, the choice of TEF does not significantly impact the differences between TMFs of different studies.


### **TL vs δ15N**

```{r, include=FALSE}
sum(is.na(TMF_data2$Regression_variable)) #checking the amount of NAs
# [1] 10
TMF_data2_rv <- TMF_data2[complete.cases(TMF_data2[ , "Regression_variable"]),]

sum(is.na(TMF_data2_rv$Regression_variable))
#[1] 0
```

```{r, eval=FALSE}
rv_model <- run_model(TMF_data2_rv, ~ Regression_variable)
save(rv_model, file = here("Rdata", "rv_model.RData"))
```

```{r, echo=FALSE, fig.cap="Note: Maximum TMF value set to 10"}
load(here("RData", "rv_model.RData"))
summary(rv_model)
r2_rv <- r2_ml(rv_model, TMF_data2_rv)

fig_rv <- orchard_plot_new(rv_model,
                            transfm="percent",
             mod = "Regression_variable",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 45,
             colour = "black",
             fill = FALSE,
             trunk.size = 0.6,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 2.4,
           y = 8, 
           label = paste0("italic(R)^{2} == ", round(r2_rv[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(size = 18),
       legend.title = element_text(size = 11),
        legend.text = element_text(size = 9),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 10),
       axis.text.x = element_text(size = 14)) +
  ylab("TMF") +
  ylim(NA, 10)

fig_rv
```

```{r, echo=FALSE, eval=FALSE}
ggsave(here("figs","regr_variab.png"),
       width = 8,
       height = 4)
```


TMFs estimated by regressing stable nitrogen isotopes (δ¹⁵N) against PFAS concentrations are **significantly lower by 47%** (p = 0.123; 95% CI: 26-85%) compared to those obtained by regressing trophic levels against PFAS concentrations.


## Geography

### Latitude

Tropical food webs are more intricate due to higher biodiversity, enabling more diverse consumer diets (Paine, 1966). Greater biomass and tissue turnover may dilute pollutants across networks. The latitude may incorporate the synergic effect of several factors, such as food web length and nature of top predator and food web baseline organism.
We predict that PFAS biomagnification estimates on food webs closer to the equator may be lower than those at higher latitudes.

```{r, include=FALSE}
TMF_data2$Latitude_abs <- abs(TMF_data2$Latitude_DD)
```

```{r, eval=FALSE}
sum(is.na(TMF_data2$Latitude_abs)) #checking the amount of NAs
#[1] 0
lat_model <- run_model(TMF_data2, ~ scale(Latitude_abs))
save(lat_model, file = here("Rdata", "lat_model.RData"))
```

```{r, echo=FALSE}
load(here("RData", "lat_model.RData"))
summary(lat_model)
r2_lat <- r2_ml(lat_model, TMF_data2)
   # R2_marginal R2_conditional 
   #  0.00220226     0.74106678 


lat_bubble <- orchaRd::mod_results(lat_model, 
                                   mod = "Latitude_abs", 
                                   group = "Study_ID")
                                   
  
fig_lat <- bubble_plot(lat_bubble,
            mod = "Latitude_abs",
            group = "Study_ID",
            x = "Latitude_abs",
            y = "ln_TMF",
            est.lwd = 1,
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black",
            g = TRUE) +
  annotate(geom ="text",
           x = 57,
           y = 3.1,
           label = paste0("italic(R)^{2} == ", round(r2_lat[1],4)),
           color = "black",
           parse = TRUE,
           size = 4) +
  #ggtitle("a)") +
  theme(plot.title = element_text(face = "bold", size = 16),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 12)) +
  ggtitle("A") +
  xlab("Latitude (absolute value)") +
  ylab("ln TMF")

fig_lat
```

```{r, echo=FALSE, eval=FALSE}
ggsave(here("figs","latitude.png"),
       width = 8,
       height = 4)
```

TMFs do not show a direct relationship with latitude.


### Geographic location

```{r, include=FALSE}
sum(is.na(TMF_data2$Location)) #checking the amount of NAs
#[1] 0
TMF_data2_loc <- TMF_data2 %>%
  mutate(Location = recode(
    Location,
    "West Asia" = "Asia",
    "East Asia" = "Asia",
    "Mediterranean Region" = "Europe")) %>% 
  group_by(Location) %>%
  filter(n_distinct(Study_ID) > 1) %>%
  ungroup()
```

```{r, eval=FALSE}
location_model <- run_model(TMF_data2_loc, ~ Location - 1)
save(location_model, file = here("Rdata", "location_model.RData"))
```

```{r, echo=FALSE, fig.cap="Note: Maximum TMF value set to 12"}
load(here("RData", "location_model.RData"))
summary(location_model)
r2_location <- r2_ml(location_model, TMF_data2_loc)


fig_loc <- orchard_plot_new(location_model,
                        transfm="percent",
             mod = "Location",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 45,
             colour = "black",
             fill = FALSE,
             trunk.size = 0.6,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 2.4,
           y = 10, 
           label = paste0("italic(R)^{2} == ", round(r2_location[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(size = 18),
       legend.title = element_text(size = 11),
        legend.text = element_text(size = 9),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 10),
       axis.text.x = element_text(size = 14)) +
  ylab("TMF") +
  ylim(NA, 12)

fig_loc
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","location.png"),
       width = 8,
       height = 6)
```


TMFs estimated in food webs from different geographical regions are not statistically different.


## Bio/Ecological characteristics

### **Type of breathing - top predator**

Biomagnification of PFAS in food webs dominated by poikilotherms (e.g., aquatic ecosystem) is lower than in food webs dominated by air breathers (e.g., terrestrial ecosystems) because of differences in metabolic rates and lipid content between these two types of organisms.
We predict that PFAS biomagnification estimates tend to be higher in food webs that include solely air-breathing organisms or a combination of air-breathing and water-breathing organisms, compared to those consisting exclusively of water-breathing organisms.

```{r, include=FALSE}
sum(is.na(TMF_data2$Breathing_type)) #checking the amount of NAs
#[1] 133
TMF_data2_bt <- TMF_data2 %>%
  filter(!is.na(Breathing_type) & Breathing_type != "") %>% 
  mutate(Breathing_type = recode(
    Breathing_type,
    "Water breathing through skin" = "Water breathing",
    ))
sum(is.na(TMF_data2_bt$Breathing_type))
# [1] 0
```

```{r, eval=FALSE}
breath_model <- run_model(TMF_data2_bt, ~ Breathing_type)
save(breath_model, file = here("Rdata", "breath_model.RData"))
```

```{r, echo=FALSE,fig.cap="Note: Maximum TMF value set to 12"}
load(here("RData", "breath_model.RData"))
summary(breath_model)
r2_breath <- r2_ml(breath_model, TMF_data2_bt)


fig_breath <- orchard_plot_new(breath_model,
                               transfm="percent",
             mod = "Breathing_type",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 2.4,
           y = 8, 
           label = paste0("italic(R)^{2} == ", round(r2_breath[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(face = "bold", size = 16),
       legend.title = element_text(size = 13),
        legend.text = element_text(size = 12),
        #axis.title.x = element_text(size = 12),
       axis.title.x = element_blank(),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 13),
       axis.text.x = element_blank()) +
  xlab("Top predator") +
  ylab("TMF") +
  ggtitle("B") +
  #scale_y_break(c(11, 13)) +
  scale_y_continuous(limits = c(0, 14), breaks = seq(0, 14, by = 1))

fig_breath
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","breathing_type_tp.png"),
       width = 8,
       height = 4)
```

TMFs estimated in food webs with a water-breathing top predator are **significantly lower by 60%** (p = 0.0104; 95% CI: 41-89%) compared to those in food webs with an air-breathing top predator.


### Ecosystem type

```{r, include=FALSE}
TMF_data2 <- TMF_data2 %>%
  mutate(Ecosystem = recode(
    Ecosystem,
    "estuarine" = "estuarine/tidal/brackish",
    "brackish" = "estuarine/tidal/brackish",
    "tidal" = "estuarine/tidal/brackish"))
```

```{r, eval=FALSE}
sum(is.na(TMF_data2$Ecosystem)) #checking the amount of NAs
#[1] 0
eco_model <- run_model(TMF_data2, ~ Ecosystem)
save(eco_model, file = here("Rdata", "eco_model.RData"))
```

```{r, echo=FALSE, warning=FALSE, fig.cap="Note: Maximum TMF value set to 12"}
load(here("RData", "eco_model.RData"))
summary(eco_model)
r2_eco <- r2_ml(eco_model, TMF_data2)

fig_eco <- orchard_plot_new(eco_model,
                            transfm="percent",
                            mod = "Ecosystem",
                            group = "Study_ID",
                            xlab = "ln_TMF",
                            legend.pos = "bottom.right",
                            k.pos = "left",
                            angle = 45,
                            colour = "black",
                            fill = FALSE,
                            trunk.size = 0.6,
                            branch.size = 3.1,
                            twig.size = 0.5) +
  annotate(geom = "text",
           x = 4.4,
           y = 10, 
           label = paste0("italic(R)^{2} == ", round(r2_eco[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(size = 18),
       legend.title = element_text(size = 11),
        legend.text = element_text(size = 9),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        axis.text.y = element_text(size = 10),
       axis.text.x = element_text(size = 14)) +
  ylab("TMF") +
  ylim(NA, 12)

fig_eco
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","ecosystem.png"),
       width = 8,
       height = 5)
```

### **Type of breathing - food web**

```{r, eval=FALSE}
sum(is.na(TMF_data2$Breathing_type_fw))
# [1] 0
bt_fw_model <- run_model(TMF_data2, ~ Breathing_type_fw)
save(bt_fw_model, file = here("Rdata", "bt_fw_model.RData"))
```

```{r, echo=FALSE, warning=FALSE, fig.cap="Note: Maximum TMF value set to 12"}
load(here("RData", "bt_fw_model.RData"))
summary(bt_fw_model)
r2_bt_fw <- r2_ml(bt_fw_model, TMF_data2)

fig_bt_fw <- orchard_plot_new(bt_fw_model,
            transfm="percent",
             mod = "Breathing_type_fw",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 2.4,
           y = 8, 
           label = paste0("italic(R)^{2} == ", round(r2_bt_fw[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(face = "bold", size = 16),
       legend.title = element_text(size = 13),
        legend.text = element_text(size = 12),
        #axis.title.x = element_text(size = 12),
       axis.title.x = element_blank(),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 13),
       axis.text.x = element_blank()) +
  xlab("Organisms") +
  ylab("TMF") +
  ggtitle("A") +
  #scale_y_break(c(11, 13)) +
  scale_y_continuous(limits = c(0, 14), breaks = seq(0, 14, by = 1)) #+
 # scale_y_break(c(11, 13))

fig_bt_fw
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","breathing_type_fw.png"),
       width = 8,
       height = 4)
```

TMFs estimated in food webs consisting exclusively of water-breathing organisms are **significantly lower by 51%** (p = 0.0125, 95% CI: 30-86%) compared to those in food webs that include both water- and air-breathing organisms.


### **Trophic position of the food web baseline**

Studies where a primary producer was used as the base of the food web are likely to have different biomagnification estimates compared to those with a primary consumer.
We predict that an extension of the food web towards the lowest trophic level will likely affect the biomagnification estimates.
```{r, include=FALSE}
sum(is.na(TMF_data2$TL_lowest)) #checking the amount of NAs
#[1] 149
TMF_data2_TL_lowest <- TMF_data2[complete.cases(TMF_data2[ , "TL_lowest"]),]
sum(is.na(TMF_data2_TL_lowest$TL_lowest))
#[1] 0
```

```{r, eval=FALSE}
TL_lowest_model <- run_model(TMF_data2_TL_lowest, ~scale(TL_lowest))
save(TL_lowest_model, file = here("Rdata", "TL_lowest_model.RData"))
```

```{r, echo=FALSE}
load(here("RData", "TL_lowest_model.RData"))
summary(TL_lowest_model)
r2_TL_lowest <- r2_ml(TL_lowest_model, TMF_data2_TL_lowest)
   # R2_marginal R2_conditional 
   #  0.02422045     0.88474369 


TL_lowest_bubble <- orchaRd::mod_results(TL_lowest_model, 
                                   mod = "TL_lowest", 
                                   group = "Study_ID")
                                   
  
fig_TL_lowest <- bubble_plot(TL_lowest_bubble,
            mod = "TL_lowest",
            group = "Study_ID",
            x = "TL_lowest",
            y = "ln_TMF",
            est.lwd = 1,
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black",
            g = TRUE) +
  annotate(geom ="text",
           x = 3.1,
           y = 3.1,
           label = paste0("italic(R)^{2} == ", round(r2_TL_lowest[1],4)),
           color = "black",
           parse = TRUE,
           size = 4) +
  #ggtitle("a)") +
  theme(plot.title = element_text(face = "bold", size = 16),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_text(size = 12)) +
  ggtitle("B") +
  xlab("Trophic level of the baseline organism") +
  ylab("ln TMF")

fig_TL_lowest
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","tl_lowest.png"),
       width = 8,
       height = 6)
```


The model shows a significant negative relationship (**0.86** factors for each trophic level; p = 0.0056) between TMF and the trophic level of the baseline organism in food webs.


### Trophic position of the top predator

Higher trophic-level organisms typically have higher lipid contents and longer lifespans. These allow more bioaccumulation over time, leading to higher concentrations in the top predators.
We predict that an extension of the food web towards the highest trophic level will likely affect the biomagnification estimates.
```{r, include=FALSE}
sum(is.na(TMF_data2$TL_highest)) #checking the amount of NAs
#[1] 149
TMF_data2_TL_highest <- TMF_data2[complete.cases(TMF_data2[ , "TL_highest"]),]
sum(is.na(TMF_data2_TL_highest$TL_highest))
#[1] 0
```

```{r, eval=FALSE}
TL_highest_model <- run_model(TMF_data2_TL_highest, ~scale(TL_highest))
save(TL_highest_model, file = here("Rdata", "TL_highest_model.RData"))
```

```{r, echo=FALSE}
load(here("RData", "TL_highest_model.RData"))
summary(TL_highest_model)
r2_TL_highest <- r2_ml(TL_highest_model, TMF_data2_TL_highest)

TL_highest_bubble <- orchaRd::mod_results(TL_highest_model, 
                                   mod = "TL_highest", 
                                   group = "Study_ID")
                                   
fig_TL_highest <- bubble_plot(TL_highest_bubble,
            mod = "TL_highest",
            group = "Study_ID",
            x = "TL_highest",
            y = "ln_TMF",
            est.lwd = 1,
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black",
            g = TRUE) +
  annotate(geom ="text",
           x = 5,
           y = 3.1,
           label = paste0("italic(R)^{2} == ", round(r2_TL_highest[1],4)),
           color = "black",
           parse = TRUE,
           size = 4) +
  #ggtitle("a)") +
  theme(plot.title = element_text(face = "bold", size = 16),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 12)) +
  ggtitle("C") +
  xlab("Trophic level of the top predator") +
  ylab("ln TMF")

fig_TL_highest
```


```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","tl_highest.png"),
       width = 8,
       height = 6)
```

The model does not show a direct linear relationship.

### Food web length

Bioaccumulation occurs at each trophic transfer. With more trophic levels, contaminants accumulate to higher concentrations at the top predators.
We predict that a broader range in trophic levels will likely increase the biomagnification estimate.
```{r, include=FALSE}
sum(is.na(TMF_data2$fw_length)) #checking the amount of NAs
#[1] 149
TMF_data2_fw_length <- TMF_data2[complete.cases(TMF_data2[ , "fw_length"]),]
sum(is.na(TMF_data2_fw_length$fw_length))
#[1] 0
```

```{r, eval=FALSE}
fw_length_model <- run_model(TMF_data2_fw_length, ~scale(fw_length))
save(fw_length_model, file = here("Rdata", "fw_length_model.RData"))
```

```{r, echo=FALSE}
load(here("RData", "fw_length_model.RData"))
summary(fw_length_model)
r2_fw_length <- r2_ml(fw_length_model, TMF_data2_fw_length)
   # R2_marginal R2_conditional 
   #  0.02422045     0.88474369 


fw_length_bubble <- orchaRd::mod_results(fw_length_model, 
                                   mod = "fw_length", 
                                   group = "Study_ID")
                                   
  
fig_fw_length <- bubble_plot(fw_length_bubble,
            mod = "fw_length",
            group = "Study_ID",
            x = "fw_length",
            y = "ln_TMF",
            est.lwd = 1,
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black",
            g = TRUE) +
  annotate(geom ="text",
           x = 3.5,
           y = 3.1,
           label = paste0("italic(R)^{2} == ", round(r2_fw_length[1],4)),
           color = "black",
           parse = TRUE,
           size = 4) +
  #ggtitle("a)") +
  theme(plot.title = element_text(face = "bold", size = 16),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_text(size = 12)) +
  ggtitle("D") +
  xlab("Number of trophic levels") +
  ylab("ln TMF")

fig_fw_length
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","fw_length.png"),
       width = 8,
       height = 4)
```

The model does not show a direct linear relationship.


### Number of species

```{r, eval=FALSE}
sum(is.na(TMF_data2$n_species)) #checking the amount of NAs
#[1] 0
n_species_model <- run_model(TMF_data2, ~scale(n_species))
save(n_species_model, file = here("Rdata", "n_species_model.RData"))
```

```{r, echo=FALSE}
load(here("RData", "n_species_model.RData"))
summary(n_species_model)

r2_n_species <- r2_ml(n_species_model, TMF_data2)

n_species_bubble <- orchaRd::mod_results(n_species_model, 
                                   mod = "n_species", 
                                   group = "Study_ID")
                                   
  
fig_n_species <- bubble_plot(n_species_bubble,
            mod = "n_species",
            group = "Study_ID",
            x = "n_species",
            y = "ln_TMF",
            est.lwd = 1,
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black",
            g = TRUE) +
  annotate(geom ="text",
           x = 30,
           y = 4,
           label = paste0("italic(R)^{2} == ", round(r2_n_species[1],4)),
           color = "black",
           parse = TRUE,
           size = 4) +
  #ggtitle("a)") +
  theme(plot.title = element_text(size = 16),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 12)) +
  xlab("Number of species in the food web")

fig_n_species
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","n_species.png"),
       width = 8,
       height = 5)
```


The model does not show a direct linear relationship.

## PFAS properties

### carbon chain length

Laboratory studies in which fish are exposed to contaminants solely through diet observed a direct positive relation between biomagnification factors and the number of carbon atoms.
We predict that an increase in the chain length increases the biomagnification estimate.
```{r, include=FALSE}
sum(is.na(TMF_data2$ccl)) #checking the amount of NAs
#[1] 23
TMF_data2_ccl <- TMF_data2[complete.cases(TMF_data2[ , "ccl"]),]
sum(is.na(TMF_data2_ccl$ccl))
#[1] 0
```

```{r, eval=FALSE}
ccl_model <- run_model(TMF_data2_ccl, ~scale(ccl))
save(ccl_model, file = here("Rdata", "ccl_model.RData"))
```

```{r, echo=FALSE}
load(here("RData", "ccl_model.RData"))
summary(ccl_model)
r2_ccl <- r2_ml(ccl_model, TMF_data2_ccl)

ccl_bubble <- orchaRd::mod_results(ccl_model, 
                                   mod = "ccl", 
                                   group = "Study_ID")
                                   
  
fig_ccl <- bubble_plot(ccl_bubble,
            mod = "ccl",
            group = "Study_ID",
            x = "ccl",
            y = "ln_TMF",
            est.lwd = 1,
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black",
            g = TRUE) +
  annotate(geom ="text",
           x = 12,
           y = 3,
           label = paste0("italic(R)^{2} == ", round(r2_ccl[1],4)),
           color = "black",
           parse = TRUE,
           size = 4) +
  ggtitle("E") +
  theme(plot.title = element_text(face = "bold", size  = 16),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 12)) +
  xlab("Carbon chain length") +
  ylab("ln TMF")

fig_ccl
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","ccl.png"),
       width = 8,
       height = 4)
```

The model does not show a direct linear relationship.

```{r, echo=FALSE, eval=FALSE}
ccl_model_quadratic <- run_model(TMF_data2_ccl, ~ ccl + I(ccl^2))
save(ccl_model_quadratic, file = here("Rdata", "ccl_model_quadratic.RData"))
```

```{r, echo=FALSE, eval=FALSE}
load(here("RData", "ccl_model_quadratic.RData"))
summary(ccl_model_quadratic)

ccl_bubble_quadratic <- orchaRd::mod_results(ccl_model_quadratic, 
                                   mod = "ccl", 
                                   group = "Study_ID")
                                   
  
fig_ccl2 <- bubble_plot(ccl_bubble_quadratic,
            mod = "ccl",
            group = "Study_ID",
            x = "ccl",
            y = "ln_TMF",
            est.lwd = 1,
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black",
            g = TRUE) +
  # annotate(geom ="text",
  #          x = 7,
  #          y = 6.2,
  #          label = paste0("italic(R)^{2} == ", round(r2_ccl_quadratic[1],4)),
  #          color = "black",
  #          parse = TRUE,
  #          size = 4) +
  #ggtitle("a)") +
  theme(plot.title = element_text(size = 12),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 6),
        axis.title.x = element_text(size = 10),
        axis.title.y = element_text(size = 10),
        axis.text.y = element_text(size = 8),
        axis.text.x = element_text(size = 8)) +
  xlab("Carbon chain length") +
  ylab("ln TMF")

fig_ccl2

# ggsave(here("figs","ccl2.png"),
#        width = 8,
#        height = 6)
```

```{r, eval=FALSE}
TMF_data3 <- TMF_data3 %>%
  filter(PFAS_ID %in% plot_data2$PFAS_ID)

TMF_data3_ccl <- TMF_data3[complete.cases(TMF_data3[ , "ccl"]),]

ccl_model2 <- run_model(TMF_data3_ccl, ~scale(ccl))

summary(ccl_model2)
r2_ccl <- r2_ml(ccl_model2, TMF_data2_ccl)

ccl_bubble2 <- orchaRd::mod_results(ccl_model2, 
                                   mod = "ccl", 
                                   group = "Study_ID")
                                   
  
fig_ccl2 <- bubble_plot(ccl_bubble2,
            mod = "ccl",
            group = "Study_ID",
            x = "ccl",
            y = "ln_TMF",
            est.lwd = 1,
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black",
            g = TRUE) +
  annotate(geom ="text",
           x = 12,
           y = 3,
           label = paste0("italic(R)^{2} == ", round(r2_ccl[1],4)),
           color = "black",
           parse = TRUE,
           size = 4) +
  ggtitle("E") +
  theme(plot.title = element_text(face = "bold", size  = 16),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 12)) +
  xlab("Carbon chain length") +
  ylab("ln TMF")

fig_ccl2
```

### PFAS class

There is no clear mechanistic explanation for the greater bioaccumulation potential of acids containing a sulfonyl functional group. Nevertheless, Jones et al. (2003) showed that sulfonic acids bind strongly to proteins.
We predict that perfluoroalkyl sulfonates (PFSA) are more bioaccumulative in the food web than perfluoroalkyl carboxylic acids (PFCAs) of the same fluorinated carbon chain length.

```{r, include=FALSE}
sum(is.na(TMF_data2$Class))
#[1] 8
TMF_data2_class <- TMF_data2[complete.cases(TMF_data2[ , "Class"]),]
sum(is.na(TMF_data2_class$Class))
#[1] 0

TMF_data2_class <- TMF_data2_class %>% 
  mutate(Class = recode(
    Class,
    "Precursor and/or intermediate" = "Precursor/intermediate"
  ))
```

```{r, eval=FALSE}
class_model <- run_model(TMF_data2_class, ~ Class)

save(class_model, file = here("Rdata", "class_model.RData"))
```

```{r, echo=FALSE}
load(here("RData", "class_model.RData"))
summary(class_model)
r2_class <- r2_ml(class_model, TMF_data2_class)

fig_class <- orchard_plot_new(class_model,
             transfm="percent",
             mod = "Class",
             group = "Study_ID",
             xlab = "ln_TMF",
             legend.pos = "bottom.right",
             k.pos = "left",
             angle = 0,
             colour = "black",
             fill = FALSE,
             trunk.size = 1,
             branch.size = 3.1,
             twig.size = 0.5) +
  annotate(geom = "text",
           x = 4.4,
           y = 8, 
           label = paste0("italic(R)^{2} == ", round(r2_class[1],4)),
           color ="black",
           parse = TRUE, 
           size = 4) +
  #ggtitle("c)")+
  theme(plot.title = element_text(face = "bold", size = 16),
       legend.title = element_text(size = 13),
        legend.text = element_text(size = 12),
        #axis.title.x = element_text(size = 12),
       axis.title.x = element_blank(),
        axis.title.y = element_text(size = 14),
        axis.text.y = element_text(size = 13),
       axis.text.x = element_text(size = 13)) +
  ggtitle("C") +
  xlab("PFAS class") +
  ylab("TMF") +
  #scale_y_break(c(11, 13)) +
  scale_y_continuous(limits = c(0, 14), breaks = seq(0, 14, by = 1))

fig_class
```

```{r, eval=FALSE, echo=FALSE}
ggsave(here("figs","class.png"),
       width = 8,
       height = 5)
```

```{r, eval=FALSE, echo=FALSE}
# Combine plots with specified heights
figX2 <- (fig_bt_fw / fig_breath) + fig_class +
  plot_layout(heights = c(1, 1, 2))

# Save the combined plot
ggsave(here("figs", "figX2.png"), plot = figX2, width = 16, height = 7, dpi = 300)

```

# Correlation assessment

The following alluvial plot provides a visual assessment of the potential correlations between categorical variables.
```{r, include=FALSE}
TMF_data2_corr <- TMF_data2 %>%
  mutate(Breathing_type = recode(
    Breathing_type,
    "Water breathing through skin" = "Water breathing",
    )) %>% 
  filter(!is.na(Breathing_type) & Breathing_type != "") %>%
  group_by(Sample_type, Breathing_type_fw, Breathing_type) %>%
  summarise(Frequency = n()) %>%
  ungroup() #%>% 
  # mutate(TL_highest = case_when(
  #   TL_highest < 3 ~ "< 3",
  #   TL_highest >= 3 & TL_highest < 3.5 ~ "3 - 3.5",
  #   TL_highest >= 3.5 & TL_highest < 4 ~ "3.5 - 4",
  #   TL_highest >= 4 & TL_highest < 4.5 ~ "4 - 4.5",
  #   TL_highest >= 4.5 & TL_highest <= 5 ~ "4.5 - 5",
  #   TL_highest >= 5 ~ "more than 5",
  #   TRUE ~ as.character(TL_highest)  # Keep original value if it doesn't fit in the specified ranges
  # )) %>%
  #filter(!is.na(TL_highest))
```


```{r, echo=FALSE}
# Create the alluvial plot - Sample type and breathign type top predator
ggplot(TMF_data2_corr,
       aes(axis1 = Sample_type, axis2 = Breathing_type_fw, axis3 = Breathing_type, y = Frequency)) +
  geom_alluvium(aes(fill = Sample_type)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 3.2, angle = 45) +
  scale_x_discrete(limits = c("Type of samples", "Breathing type (food web)", "Breathing type (top predator)"), expand = c(.05, .05)) +
  scale_fill_npg() +
  labs(x = "Categorical variables", y = "TMF frequency") +
  theme_classic() +
  theme(legend.position = "none")
```


```{r, echo=FALSE, eval=FALSE}
ggsave(here("figs","alluvial.png"),
       width = 10,
       height = 8)
```


```{r, include=FALSE}
TMF_data2_loc_agg <- TMF_data2_loc %>%
  group_by(Regression_variable, Location) %>%
  summarise(Frequency = n()) %>%
  ungroup()

# Create the alluvial plot - Regression variable and location
ggplot(TMF_data2_loc_agg,
       aes(axis1 = Regression_variable, axis2 = Location, y = Frequency)) +
  geom_alluvium(aes(fill = Regression_variable)) +
  geom_stratum() +
  geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_x_discrete(limits = c("Regression variable", "Geographical location"), expand = c(.05, .05)) +
  labs(x = "Categories", y = "Frequency") +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
cor.test(TMF_data2$fw_length, TMF_data2$TL_highest)
cor.test(TMF_data2$fw_length, TMF_data2$n_species)
```

# Full model

Mixed-effects meta-regression model. Multivariate meta-analysis model with multiple covariates, using a multilevel random-effects approach.

```{r}
TMF_data_fmodel <- TMF_data2 %>% 
  mutate(Sample_type = recode(
    Sample_type,
    "specific tissues and whole-organisms" = "mixed"
  )) %>% 
  mutate(Conc_determ_method = recode(
    Conc_determ_method,
    "polar lipid equivalent corrected concentrations" = "Normalized",
    "wet weight concentrations (ww)" = "Not normalized",
    "protein equivalent corrected concentrations (pw)" = "Normalized",
    "lipid equivalent corrected concentrations (lw)" = "Normalized",
    "dry weight concentrations (dw)" = "Not normalized",
    "apparent chemical activities corrected concentrations" = "Normalized",
    "albumin equivalent corrected concentrations" = "Normalized",
    "fresh weight (fw)" = "Not normalized")) %>%
  filter(!is.na(Breathing_type) & Breathing_type != "") %>% 
  mutate(Breathing_type = recode(
    Breathing_type,
    "Water breathing through skin" = "Water breathing",
    )) %>% 
  mutate(Class = recode(
    Class,
    "Precursor and/or intermediate" = "Precursor/intermediate"
  ))
  
VCV_fmodel <- vcalc(vi = TMF_data_fmodel$ln_TMF_se^2, 
             cluster = TMF_data_fmodel$FW_ID, 
             obs = TMF_data_fmodel$TMF_ID, 
             rho = 0.5)
```


```{r, eval=FALSE}
full_model <- rma.mv(yi = ln_TMF,
                     V = VCV_fmodel, 
                     mods = ~  1 + 
                       Sample_type +
                       Conc_determ_method +
                       #Censored_data_strategy +
                       #TEF +
                       Breathing_type_fw +
                       Breathing_type +
                       Class +
                       scale(Latitude_abs) +
                       #scale(TL_lowest) +
                       #scale(TL_highest) +
                       #scale(fw_length) +
                       scale(ccl),
                     random = list(~1|Study_ID, 
                                   ~1|FW_ID, 
                                   ~1|PFAS_ID, 
                                   ~1|TMF_ID 
                                   ),
                     test = "t",
                     data = TMF_data_fmodel,
                     sparse = TRUE)

save(full_model, file = here("Rdata", "full_model.RData"))
```

```{r, echo=FALSE}
load(here("RData", "full_model.RData"))
summary(full_model)
r2_ml(full_model, TMF_data_fmodel)
```

# Model selection
 
```{r, eval=FALSE}
eval(metafor:::.MuMIn) # use eval() function to extract helper functions from MuMIn and make them usable in metafor.
mod.candidate <- dredge(full_model, beta = "none", evaluate = TRUE, rank = "AICc", trace=2) # dredge to produce all possible candidate models

# Save the candidate models
save(mod.candidate, file = here("Rdata", "mod_candidate.RData"))
```

```{r}
# Next step, let’s select a sets of best models.
load(here("RData", "mod_candidate.RData"))
subset(mod.candidate, delta <= 4, recalc.weights = FALSE)
# Sum of weights for each variable included in the mod.candidate
sw(mod.candidate)
```

```{r}
weights <- read_csv(here("Rdata", "aic_weights.csv")) #upload data from sw(mod.candidate)

weights <- weights %>% 
  mutate(weights_percentage = round( Sum_of_weights * 100))

weights$Predictor <- factor(weights$Predictor, levels = weights$Predictor[order(weights$weights_percentage, weights$R2_marginal)])


AIC_weights <- ggplot(weights, aes(Predictor, Sum_of_weights)) +
  geom_col(aes(fill = R2_marginal), width = 0.7) +  # Gradient fill based on R2_marginal
  geom_text(aes(label = paste0(weights_percentage, "%"), x = Predictor), 
            position = position_stack(vjust = 0.5), 
            size = 3) +
  geom_text(aes(label = paste("R2 =", sprintf("%.3f", R2_marginal)), x = Predictor, y = max(Sum_of_weights)), 
            position = position_stack(vjust = 1.07), 
            size = 3, color = "black") +
  theme_light() +
  coord_flip() +
  scale_fill_gradient(low = "skyblue", high = "royalblue", name = "R2 Marginal") +  # Color gradient
  scale_x_discrete(name = "Predictor") +
  scale_y_continuous(name = "AIC weights",
                     breaks = seq(0, 1, by = 0.2)) +
  theme(legend.position = "right",  # Move legend to the right
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        axis.text = element_text(size = 10),
        panel.grid.major = element_line(color = "grey", 
                                        linewidth = 0.2, 
                                        linetype = "dashed"),
        panel.grid.minor = element_line(color = "grey", 
                                        linewidth = 0.2, 
                                        linetype = "dotted"))
AIC_weights

# ggsave(here("figs","aic_weights.png"),
#        width = 10,
#        height = 5)
```

# Publication bias

## Visual inspection - Funnel plot

```{r}
# Increase text size for x and y axes
par(cex.axis = 1.5)

# Increase label size for x and y axes
par(cex.lab = 1.5)

funnel(
  full_model, 
  yaxis = "seinv", # Inverse of standard error (precision) as the y axis
  level = c(90, 95),  # levels of statistical significance highlighted 
  shade = c("white", "gray55"), # shades for different levels of statistical significance
  back = "#EBEBEB",
  legend = FALSE, # display legend
  ylab = "Precision (1/SE)", 
  cex.lab = 1.5, 
  digits = 1, 
  xlim = c(-5,5)
  )
```


## Time-lag bias

```{r, eval=FALSE}
MLMR_mod_year.c <- metafor::rma.mv(ln_TMF,
                            VCV,
                            mods = ~ scale(year_publication),
                            random = list(~1|Study_ID,
                                              ~1|FW_ID,
                                              ~1|PFAS_ID,
                                              ~1|TMF_ID
                                              ),
                            data = TMF_data2)
save(MLMR_mod_year.c, file = here("Rdata", "MLMR_mod_year.c.RData"))
```

```{r, echo=FALSE}
load(here("RData", "MLMR_mod_year.c.RData"))
summary(MLMR_mod_year.c)
r2_pbias <- r2_ml(MLMR_mod_year.c, TMF_data2)
pb_bubble <- orchaRd::mod_results(MLMR_mod_year.c,
                                  mod = "year_publication",
                                  group = "Study_ID",
                                  data = dat)

bias2 <- orchaRd::bubble_plot(pb_bubble,
                     group = "Study_ID",
                     mod = "year_publication",
            legend.pos = "bottom.right",
            k.pos = "bottom.left",
            ci.col = "red",
            pi.col = "black",
            est.col = "black") +
  annotate(geom ="text",
           x = 2017,
           y = 3,
           label = paste0("italic(R)^{2} == ", round(r2_pbias[1],4)),
           color = "black",
           parse = TRUE,
           size = 4) +
  ggtitle("F") +
  theme(plot.title = element_text(face = "bold", size  = 16),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_text(size = 14)) +
  xlab("Publication year") +
  ylab("ln TMF") +
  scale_x_continuous(breaks = seq(2003, 2024, by = 5), limits = c(2003, 2024))
bias2
```

```{r, eval=FALSE, echo=FALSE}
# Combine plots with specified heights
figX3 <- (fig_lat + fig_TL_lowest) / (fig_TL_highest  + fig_fw_length) / (fig_ccl + bias2)

# Save the combined plot
ggsave(here("figs", "figX3.png"), plot = figX3, width = 16, height = 10, dpi = 300)

```

::: info
There is no evidence of publication time bias.
:::